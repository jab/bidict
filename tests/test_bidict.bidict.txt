Test script for bidict.bidict::

    >>> from bidict import bidict
    >>> keys = (1, 2, 3)
    >>> vals = ('one', 'two', 'three')
    >>> bi = bidict(zip(keys, vals))
    >>> bi == bidict({1: 'one', 2: 'two', 3: 'three'})
    True

Works like dict for getting and changing forward mappings::

    >>> bi[2]
    'two'
    >>> bi[2] = 'twain'
    >>> bi[2]
    'twain'
    >>> bi[4]
    Traceback (most recent call last):
        ...
    KeyError: 4
    >>> del bi[2]
    >>> bi.pop(3)
    'three'
    >>> bi
    bidict({1: 'one'})

``put`` can also be used to update mappings::

    >>> bi.put(0, 'zero')
    >>> bi[0]
    'zero'
    >>> del bi[0]
    >>> bi.put(1, 'one')
    >>> bi
    bidict({1: 'one'})
    >>> bi.put(1, 'aught')

bidicts maintain references to their inverses via the ``inv`` property,
which can also be used to access or modify them::

    >>> bi.inv
    bidict({'aught': 1})
    >>> bi.inv['aught']
    1
    >>> bi.inv['aught'] = 'one'
    >>> bi
    bidict({'one': 'aught'})
    >>> bi.inv.pop('aught')
    'one'
    >>> bi.inv.update(one=1)
    >>> bi
    bidict({1: 'one'})
    >>> bi.inv.inv is bi
    True
    >>> bi.inv.inv.inv is bi.inv
    True

bidicts work with ``inverted`` as expected::

    >>> from bidict import inverted
    >>> biinv = bidict(inverted(bi))
    >>> biinv
    bidict({'one': 1})

This created a new object (equivalent but not identical)::

    >>> biinv == bi.inv
    True
    >>> biinv is bi.inv
    False

Inverting the inverse should round-trip::

    >>> bi == bidict(inverted(inverted(bi)))
    True
    >>> bi = bi.inv
    >>> bi == bidict(inverted(inverted(bi)))
    True

The rest of the ``MutableMapping`` interface is supported::

    >>> bi.get('one')
    1
    >>> bi.get('zero')
    >>> bi.get('zero', 0)
    0
    >>> list(bi.keys())
    ['one']
    >>> list(bi.values())
    [1]
    >>> list(bi.items())
    [('one', 1)]
    >>> bi.setdefault('one', 2)
    1
    >>> bi.setdefault('two', 2)
    2
    >>> bi.pop('one')
    1
    >>> bi.popitem()
    ('two', 2)
    >>> bi.popitem()
    Traceback (most recent call last):
    ...
    KeyError: 'popitem(): bidict is empty'
    >>> bi.inv.setdefault(3, 'three')
    'three'
    >>> bi
    bidict({'three': 3})
    >>> len(bi)  # calls __len__
    1
    >>> [key for key in bi]  # calls __iter__, returns keys like dict
    ['three']
    >>> 'three' in bi  # calls __contains__
    True
    >>> list(bi.keys())
    ['three']
    >>> list(bi.values())
    [3]
    >>> bi.update([('four', 4)])
    >>> bi.update({'five': 5}, six=6, seven=7)
    >>> sorted(bi.items(), key=lambda x: x[1])
    [('three', 3), ('four', 4), ('five', 5), ('six', 6), ('seven', 7)]
    >>> bi.clear()
    >>> bi
    bidict({})

Initializing with collapsing mappings fails::

    >>> bidict([(1, 1), (2, 2), (1, 2)])  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    CollapseException: ((1, 1), (2, 2))

Collapsing updates fail::

    >>> b = bidict({1: 1, 2: 2})
    >>> b[1] = 2  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    CollapseException: ((1, 1), (2, 2))
    >>> b.inv[2] = 1  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    CollapseException: ((1, 1), (2, 2))
    >>> b.update({1: 2})  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    CollapseException: ((1, 1), (2, 2))

``forceput`` can be used instead::

    >>> b.forceput(1, 2)
    >>> b
    bidict({1: 2})

Trying to insert an existing mapping does not raise, and is a no-op::

    >>> b = bidict({1: 'one'})
    >>> b[1] = 'one'
    >>> b[1]
    'one'
    >>> b.inv['one'] = 1
    >>> b.inv['one']
    1
